> 访问器属性需要重看
>> typeof使用场景 和 instance
[toc]
# 对象
## 1. 理解对象
### 1.1 创建对象方式演变
>new Object的方式和对象字面量的方式创建对象是等价的；并且这两种方式都跟通过构造函数创建对象的方式是有区别，具体区别是newObject和对象字面量的方式使用同一接口创建很多对象，会产生大量重复的代码

+ 原始方式：通过new Object方式
+ 目前方式：通过对象字面量方式
```javascript
// 原始方式：通过new Object方式
var person = new Object();
person.name = "xiaoming";
person.age = 18;
person.sayName = function() {
    alert(this.name);
};      //注意分号

// 目前方式：通过对象字面量方式
var person = {
    name: "hello",
    age: 18,
    sayName: function() {
      alert(this.name)
    }
};
```
### 1.2 对象默认内部属性类型
+ 我们这里先将人为设置的属性称为对象的外部属性
+ ECMAScript为每个对象设置了内部属性
+ 对象的内部属性用于限制对象的外部属性
+ 内部属性分为：数据属性和访问器属性
#### 1.2.1 数据属性
> 内部数据属性属性包含一个数值的位置，在这个位置可以读取和写入值；有4个数据属性

##### A. 基本内部默认属性
+ [[ Configurable ]]：能否通过delete删除属性从而重新定义属性或者修改属性的特性（修改为访问器属性），默认true
+ [[ Enumerable ]]：能否通过for-in遍历属性，默认为true
+ [[ Writable ]]：能否修改属性的值，默认为true
+ [[ Value ]]：包含属性的值，读取属性值时从这个位置读，写入属性值时从这个位置写，默认undefined
```javascript
// 定义如下对象，此时Configurable、Enumerable、Writable的默认属性都是true
// Value属性的值是"john"
var person = {
    name: "john"
};
```
##### B. 基本内部属性的修改
+ 基本内部属性需要通过`object.defineProperty(属性所在对象，要修改的属性名，内部属性对象)`方法修改
+ 在调用`object.defineProperty()`方法时如果不指定configurable、enumerable、writable默认都是false
+ 当把一个属性设置为不可配置（configurable=false）,那么属性就不能再修改为可配置的了。
```javascript
// 示例
var person = {};
Object.defineProperty(person, "name", {
    writable: false,
    value: "john"
});
alert(person.name);     // john
person.name = "Bob";
alert(person.name);     // john

//上述代码解析：非严格模式下这句代码person.name = "Bob";将被忽略，严格模式下赋值操作符导致报错
```
#### 1.2.2 访问器属性
>访问器属性不包含属性值，他们包含一对函数getter和setter
>> 不一定非要同事设置get和set，只设置get意味着属性不能写，尝试写入属性会被忽略，严格模式下跑出错误；同理set
+ [[ Configurable ]]：能否通过delete删除属性从而重新定义属性或者修改属性的特性（修改为数据属性），默认true
+ [[ Enumerable ]]：能否通过for-in遍历属性，默认为true
+ [[ Set ]]：用户写入属性值
+ [[ Get ]]：用于读取属性值
```javascript
// 示例
var book = {
    _year: 2004,
    edition: 1
};
Object.defineProperty(book, "year", {
    set: function(newValue) {
        if (newValue > 2004) {
            this._year = newValue+3;
            this.edition += (newValue - 2004);
        }
    },
    get: function() {
        return this._year;
    }
});

book.year = 2005;
alert(book.edition);    //2
alert(book.year);       //2005  此处的book.year就是访问器属性
alert(book._year);      //2008
```
### 1.3 定义多个属性
+ 使用Object.defineProperties()方法定义多个属性
```javascript
// 示例：
var book = {};
Object.defineProperties(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        set: function() {
            if (newValue > 2004) {
                this._year = newValue+3;
                this.edition += (newValue - 2004);
            }
        },
        get: function() {
            return this._year;
        }
    }
});
// 解析：以上代码创建了2个数据属性_year和edition，还有一个访问器属性year；并且最终的对象跟1.2.2的示例相同
```

### 1.4 读取属性的特性
+ 通过Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符
+ 方法接受两个参数：是对象和尧都区其描述符的属性名称
+ getOwnPropertyDescriptor()的返回值：是一个对象
```javascript
var book = {};
Object.defineProperties(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        set: function() {
            if (newValue > 2004) {
                this._year = newValue+3;
                this.edition += (newValue - 2004);
            }
        },
        get: function() {
            return this._year;
        }
    }
});

var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
alert(descriptor.configurable);     // false
alert(descriptor.value);            // 2004
alert(typeof descriptor.get);       // "undefined"

var descriptor = Object.getOwnPropertyDescriptor(book, "year");
alert(descriptor.configurable);     // false
alert(descriptor.value);            // undefined
alert(typeof descriptor.get);       // "undefined"
```

## 2. 创建对象

### 2.0 创建对象相关知识总结
+ ECMAScript中无法创建类，所以js使用函数封装特定接口来创建对象

+ 一般情况，构造函数的函数名首字母大写

+ 任何函数，只要通过new操作符来调用，那它就可以作为构造函数，而任何函数如果不通过new操作符来调用，那它就是普通函数,(当构造函数作为普通函数调用时，this指向的window对象)

+ 每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含有特定类型的所有实例共享的属性和方法

+ 无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象；

+ 创建自定义函数其原型对象默认自动获得一个constructor属性，至于其他方法则都是从Object继承而来

+ 当调用构造函数创建第一个新实例后，改实例的内部将包含一个指针，指向构造函数的原型对象（__proto__就是原型对象实例prototype）

+ 构造函数中的prototype属性可以通过Person.prototype进行访问，但是实例对象person1中的prototype是不能通过person1.prototype属性进行访问的；可以通过Object.getPrototypeOf()获取，`Object.getPrototypeOf(person1) === Person.prototype`

+ 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值

+ for-in可以获取能够通过对象访问的，可枚举的属性，包括实例和原型中所有属性

+ 搜索属性方法基本原理：搜索先从对象实例本身开始，如果在实例中找到了具有给定名字的睡醒，则返回该属性的值，如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性，如果查找到则返回该属性的值。

+ 在实例和原型中具有相同属性名时，原型中的属性名会被屏蔽。

+ new操作符经历的4个步骤：
    // 创建一个新对象
    // 将构造函数的作用域赋值给新对象（this就指向了对象；看出this指代的对象的执行上下文）
    // 执行构造函数代码
    // 返回新对象

![](image/../../image/WechatIMG2.jpeg)


### 2.1 工厂模式
+ 主要优点：解决了原始的new Object方式和对象字面量方式针对统一接口创建多个对象时的产生的重复代码问题
+ 主要缺点：工厂模式产生的对象无法使用instanceof区分出对象的具体类型
```javascript
// 工厂模式代码示例
function Createperson(name, age){
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.sayName = function (){
        alert(this.name);
    };
    return obj
}
var person1 = Createperson("john", 18);
var person2 = Createperson("BOB", 20);
```
### 2.2 构造函数模式
+ 优点：解决了工厂模式的缺点问题，也就是创建自定义函数可以通过实例标识为一种特定的类型
+ 缺点：由于函数也是对象，所以构造函数中的方法也是一个对象，这就导致多个构造函数实例中的方法对象也不同拥有不同，浪费了内存
```javascript
function Person(name, age){
    this.name = name;
    this.age = age;
    this.sayName = function (){
        alert(this.name)
    };
    //等价于this.sayName = new Funtion("alert(this.name)")
    //记得函数也是对象
}
var person1 = new Person("john", 18);
var person2 = new Person("BOB", 20);
```

### 2.3 原型模式
+ 优点：解决了构造函数模式的缺点相同接口下的多个对象方法占用不同内存的问题；解决办法是将方法写在原型对象中，所有实例对象共享
+ 缺点：全部写在
```javascript
// 基本原型模式
function Person(){ }
Person.prototype.name = "john";
Person.prototype.sayName = function (){
    alert(this.name)
};
var person1 = new Person();
var person2 = new Person();
person1.sayName();  //john
person2.sayName();  //john
person1.name = "bob";
person1.sayName();  //bob 同名属性时屏蔽原型对象属性
delete person1.name;
person1.sayName();  //john 删除实例中name，则展示原型中的name
```
```javascript
// 通过isPrototypeof()方法确定实例和原型对象之间的关系
alert(Person.prototype.isPrototypeof(person1))  //true

// 通过Object.getPrototypeOf()获取对象实例的原型
alert(Object.getPrototypeOf(person1) === Person.prototype);//true
alert(Object.getPrototypeOf(person1).name);//person1.name

// 通过hasOwnProperty()方法可以判断哪些属性是对象实例的，哪些属性是原型对象的，本方法是从Object继承来的
alert(person1.hasOwnProperty("age")) //实例true，原型false

// 通过Object.keys()方法获取一个对象的所有可枚举的属性,返回所欲可枚举的字符串数组(和for-in的顺序是一样的)
alert(Object.keys(Person.prototype));

// 通过Object.getOwnPropertyNames()获取对象的所有属性，包括不可枚举的。(比如下面会输出不可枚举的constructor属性))
alert(Object.getOwnPropertyNames(Person.prototype));
```

```javascript
// 修改原型对象
function 
```
### 2.4 组合使用构造函数模式和原型模式
### 2.5 动态原型模式
### 2.6 寄生构造函数模式
### 2.7 稳妥构造函数模式











