# 函数的4种调用方式
+ `在es6箭头函数之前的时代`，函数内部的this是由函数的调用方式决定的
+ 函数内部的this跟函数名大小写和书写位置(写在全局的还是局部)无关

## 1. 函数调用
```js
// 示例1：
var age = 20;
var p = {
    age: 15,
    say: function(){
        console.log(this.age);
    }
};
var fun = p.say;
fun();      // 20——>函数调用
```

```js
// 示例2：
function fn(callback){
    var age = 18;
    callback();         // 这种调用方式指向window
}
fn(function(){          //这里的匿名函数作用域是window
    console.log(age);   //undefined
    var age = 15;
});
```

## 2. 方法调用
```js
// 示例1：
var age = 20;
var p = {
    age: 15,
    say: function(){
        console.log(this.age);
    }
};
p.say();    // 15 ——>方法调用
```

```js
// 示例2：
var age = 20;
var p = {
    age: 15,
    say: function(){
        console.log(this.age);
    }
};
p.say();    // 15 ——>方法调用
var tom = { tsay: p.say, age: 10 };
tom.tsay(); //10 ——>指向tom还是方法调用
```

```js
// 示例3：
var age = 20;
function Person(){
    this.age = 15;
}
Person.prototype.run = function(){
    console.log(this.age);
}
var p = new Person();
p.run();    // 15 ——>方法调用
```



## 3. new调用(构造函数)
```js
// 示例1：
function Person(age){
    this.age = age;
}
//通过new的方式调用，返回的是this就是实例p对象
var p = new Person(10);
console.log(p.age);

// 此时内部的this指向window，age是全局的属性
Person(20);
```
```js
// 经典示例2(好好体会)：
function Fun(){
    var _init = Fun.prototype._init;
    return new _init();
}
Fun.prototype = {
    construct: Fun,
    length: 100,
    _init: function(){
        console.log(this.length);
    }
}
```
## 4. 上下文方式（call&apply&bind）

# this指向问题
> 主要取决于方法.之前的对象；如果是直接调用方法则是全局对象
>> 影响this的几个点：call、apply、bind、箭头函数
+ ***理解1***：在全局函数中this等于window；而当函数被作为某个对象的方法调用时，this等于那个对象；匿名函数的执行环境具有全局性，因此其this通常指向window
+ ***理解2***：每个函数在被调用时都会自动取的两个特殊变量：this和arguments，内部函数在搜索这两个变量时，只会搜索到其活动对象位置，因此永远不可能直接访问外部函数中的这两个变量。（不过可以将外部作用于中的this保存到闭包函数可以访问中的外部变量中）
